# Server overview

The server has two main responsibilities.
The first is to handle API calls from the client to store, update and delete information, such as competitions or users.
It also needs to make sure that only authorized people can access these.
The other responsibility is to sync slides, timer and answers between clients in an active competition.
Both of these will be described in more detail below.

## Receiving API calls

An API call is a way for the client to communicate with the server.
When a request is received the server begins by authorizing it (making sure the person sending the request is allowed to access the route).
After that it confirms that it got all information in the request that it needed.
The server will then process the client request.
Finally it generates a response, usually in the form of an object from the database.
All of these steps are described in more detail below.

### Routes

Each existing route that can be called is specified in the files in the `app/apis/` folder.
All available routes can also be seen by navigating to `localhost:5000` after starting the server.

### Authorization

When the server receives an API call it will first check that the call is authorized.
The authorization is done using JSON Web Tokens (JWT) by comparing the contents of them with what is expected.
Whenever a client logs into an account or joins a competition, it is given a JWT generated by the server, and the client will need to use this token in every subsequent request sent to the server in order to authenticate itself.

The needed authorization is specified by the `@protect_route()` decorator.
This decorator specifies who is allowed to access this route, which can either be users with specific roles, or people that have joined competitions with specific views.
If the route is not decorated everyone is allowed to access it, and the only routes currently like that is, by necessity, logging in as a user and joining a competition.

#### JSON Web Tokens (JWT)

JSON Web Tokens (JWT) are used for authentication, both for API and socket events.
A JWT is created on the server when a user logs in or connects to a competition.
Some information is stored in the JWT, which can be seen in the file `server/app/apis/auth.py`.
The JWT is also encrypted using the secret key defined in `server/configmodule.py`.
(NOTE: Change this key before running the server in production).
The client can read the contents of the JWT but cannot modify them because it doesn't have access to the secret key.
This is why the server can simply read the contents of the JWT to be sure that the client is who it says it is.

### Parsing request

After the request is authorized the server will need to parse the contents of the request.
The parsing is done with [reqparse](https://flask-restx.readthedocs.io/en/latest/parsing.html) from RestX (this module is deprecated and should be replaced).
Each API call expects different parameters in different places and this is specified in each of the files in `app/apis/` folder, together with the route.

### Handling request

After the request has been authorized and parsed the server will process the request.
What it does depends on the route and the given arguments, but it usually gets, edits or deletes something from the database.
The server uses an SQL database and interfaces to it via SQLAlchemy.
Everything related to the database is located in the `app/database/` folder.

### Responding

When the server har processed the request it usually responds with an item from the database.
Converting a database object to json is done with [Marsmallow](https://marshmallow.readthedocs.io/en/stable/).
This conversion is specified in two files in the folder `app/core/`.
The file `schemas.py` converts a record in the database field by field.
The file `rich_schemas.py` on the other hand converts an `id` in one table to an entire object in the another table, thus the name rich.
In this way, for example, an entire competition with its teams, codes, slides and the slides' questions and components can be returned in a single API call.

## Active competitions

Slides, timers, and answers needs to be synced during an active presentation.
This is done using SocketIO together with flask_socketio.
Sent events are also authorized via JWT, basically the same way as the for the API calls.
But for socket events, the decorator that is used to authenticate them is `@authorize_user()`.
Whenever a client joins a competition they will connect via sockets.
A single competition cannot be active more than once at the same time.
This means that you will need to make a copy of a competition if you want to run the same competition at several locations at the same time.
All of the functionality related to an active competition and sockets can be found in the file `app/core/sockets.py`.
The terms *active competition* and *presentation* are equivalent.

### Starting and joing presentations

Whenever a code is typed in to the client it will be checked via the `api/auth/login/code` API call.
If there is such a code and it was an operator code, the client will receive the JWT it will need to use to authenticate itself.
If there is such a code and the associated competition is active, the client will also receive a JWT for its corresponding role.
Both of these cases will be handled by the default `connect` event, using the JWT received from the API call.
The server can see what is stored in the JWT and do different things depending on its contents.

### Syncing between clients

[comment]: # (What does `sync` mean? It isn't explained)

The operator will emit the `sync` event and provide either a slide or a timer to update it on the server.
The server will then send `sync` to all connected clients with the updated values, regardless of what was actually updated.
The server will also store the timer and active slide in order to `sync` clients when they join.
The operator can also emit `end_presentation` to disconnect all clients from its competitions.
This will also end the presentation.
